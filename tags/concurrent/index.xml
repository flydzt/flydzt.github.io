<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrent on FLYDZT</title>
    <link>https://flydzt.github.io/tags/concurrent/</link>
    <description>Recent content in concurrent on FLYDZT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Apr 2020 22:54:52 +0000</lastBuildDate>
    
	<atom:link href="https://flydzt.github.io/tags/concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>同步的一些思考与java实现</title>
      <link>https://flydzt.github.io/post/%E5%90%8C%E6%AD%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 27 Apr 2020 22:54:52 +0000</pubDate>
      
      <guid>https://flydzt.github.io/post/%E5%90%8C%E6%AD%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/</guid>
      <description>竞争和同步 多个线程读写某些数据,结果依赖于精确时序,就是竞争.或者说,资源是共享的,状态是重要的,多个线程同时读写,会产生不可预期的结果.
而同步则是为了让结果唯一(可预测).
为了同步,需要临界区.首先,不允许两个线程同时处在临界区,其次,不能让一个线程无限期等待进入临界区.
在临界区之外,一个线程不能阻塞其他线程.</description>
    </item>
    
    <item>
      <title>aqs基本原理(代码注释)</title>
      <link>https://flydzt.github.io/post/aqs%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 11 Apr 2020 12:38:07 +0000</pubDate>
      
      <guid>https://flydzt.github.io/post/aqs%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description>基本思路 通过cas去获取主动权,失败就去排队.持有锁的解锁后唤醒下一个, 被唤醒后的线程看看自己是不是排到了第一.
值得注意的是,排队时候是可以取消的.从队列中删除某个节点,不能出现死循环,指向错误的问题.
由于支持节点的取消:</description>
    </item>
    
    <item>
      <title>juc的一些基础知识</title>
      <link>https://flydzt.github.io/post/juc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 04 Apr 2020 14:59:08 +0000</pubDate>
      
      <guid>https://flydzt.github.io/post/juc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>java.util.concurrent java 1.5提供了juc包,实现了常用的工具类.包括线程池,异步IO,轻量级任务框架等.
volatile volatile关键字保证各线程间对于同一个变量,总是能看到最新值.是一种稍弱的同步机制.对于volatile变量,编译器和运行时不会进行重排序,并且不会被缓存在寄存器或者对其他处理器不可见的地方.</description>
    </item>
    
  </channel>
</rss>