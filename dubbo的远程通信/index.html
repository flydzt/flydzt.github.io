<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="解决一类问题而不是一个问题">
        <link rel="shortcut icon" href="/images/hhh.jpg"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="flydzt" href="">
        <title>dubbo的远程通信 | flydzt</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.0"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/images/hhh.jpg" alt="flydzt" /></a>
            <h1><a href="/">flydzt</a></h1>
            <p></p>
            <div id="follow-icons">
          <a href="http://github.com/flydzt" target="_blank" rel="noopener"><i class="fa fa-github-square fa-2x"></i></a>
          </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  十二月 29, 2019
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/java/'>java</a> 
    
      <a href='/tags/dubbo/'>dubbo</a> 
    
      <a href='/tags/io/'>io</a> 
    
    </span>
  

  <h1 class="post-title">dubbo的远程通信</h1>
  <section class="post-content article-entry">
    <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>应用程序的远程通信,无非是Server开一个端口去监听(listen, 例如用一个队列最多阻塞1024个客户端等待accept, 超过的直接拒绝).</p>
<p>Client进行连接(connect)并拿到一个句柄,Server也拿到(accept, 从监听队列拿出)一个句柄.依靠这两个句柄就可以进行全双工的读写(write,read).</p>
<h3 id="TCP-NO-DELAY"><a href="#TCP-NO-DELAY" class="headerlink" title="TCP_NO_DELAY"></a>TCP_NO_DELAY</h3><p>在使用时,可以根据场景做一些优化.例如可以关闭nagle算法来降低延迟,但是增加了发包的次数.</p>
<p>由于协议是分层的,在tcp层增加包的数量,同时需要传递链路层传输层重复的信息(本来可以在一个包里,为了减少延迟而拆开了),而应用的协议比tcp层更高,又进一步降低了一个包中信息的有效比例.</p>
<p>在传输信息量少的时候更甚.虽然看着带宽占了很多,但是大多数数据是为了拆包和相应的ack而导致的,和业务无关. 简言之就是”空间”(信道容量)换”时间”(延迟).</p>
<p>网络传输繁忙也意味着大量的中断,为提高效率可以合并发送.这都是需要权衡的.</p>
<p>通常,业务的数据进入系统调用后(write调用成功只是进入缓冲区,write阻塞说明缓冲区已满.为重试需要,只有收到对方ack才会清理缓冲区内容)就认为发送成功了,但这部分数据可能还未真正发送,并且可能丢包(重试由系统保证). 由此可能会产生很多无意义的数据发送(服务端认为未超时,但是由于发送不及时或丢包重试,客户端认为超时了).</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>Server可以采取多路复用等机制来提高面对多Client时的效率. 处理多client经历了几个阶段,为每个连接分配进程,为每个连接分配线程,使用select,使用poll,使用epoll(linux场景)…</p>
<p>当然,多路复用只是一个手段.重要是在和业务结合,明白io线程在做什么. 例如如果大量处在wait阶段,说明并没有数据的收发.</p>
<p>多路复用的目的是降低找到需要处理的连接的开销.他不是一个通信框架的全部.</p>
<h2 id="dubbo的通信模块"><a href="#dubbo的通信模块" class="headerlink" title="dubbo的通信模块"></a>dubbo的通信模块</h2><p>本地调用的几个基本要素为: 方法名,返回类型,参数.</p>
<p>如何做到远程调用? 就是将这些要素传递给远程即可.</p>
<p>客户端需要将要调用的方法,调用的参数告知服务端. 服务端接收后,在本地调用客户端指定的方法,并传递对应的参数,再把对应的结果返回给客户端.</p>
<p>看起来很简单,但是需要处理其中的几个问题.</p>
<ol>
<li>客户端和服务端如何保持连接和传递数据?</li>
<li>客户端如何告知服务端方法和参数,并且服务端能解析出来? 同样的,服务端如何将返回结果告知客户端?</li>
</ol>
<h3 id="通信组件"><a href="#通信组件" class="headerlink" title="通信组件"></a>通信组件</h3><p>在dubbo里, 可以使用几个通信框架来实现连接交换数据, 默认的方案是netty.</p>
<h3 id="io线程"><a href="#io线程" class="headerlink" title="io线程"></a>io线程</h3><p>boss只有1个线程,worker线程池则可以通过protocol.iothreads参数来设置,默认为cpu数量+1.当然为了防止浪费线程, 最大数量为32.</p>
<p>如果一台机器部署了多个dubbo应用,则iothreads是需要被考虑到的,(当然其他参数也是需要考虑的).</p>
<p>如果是使用容器(容器一般就是一个应用),则该值就是容器被分配的cpu数量+1.</p>
<h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><p>dubbo使用netty非常简单,每一个netty的handler都会转给dubbo自己的handler.</p>
<p>netty的pipeline:</p>
<ol>
<li><p>inbound:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    decoder--&gt;server&#x2F;client-idle-handler--&gt;handler</span><br></pre></td></tr></table></figure>
</li>
<li><p>outbound:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">   handler--&gt;server&#x2F;client-idle-handler--&gt;encoder</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>decode和encode是为了编解码.</p>
<p>server-idle-handler使用了netty的IdleSateHandler来实现心跳监听.如果超过读/写的idle时间,将会发送一个IdleStatEvent.</p>
<p>handler的类是NettyServerHandler以及NettyClientHandler,可以处理IdleStatEvent,关闭channel.该类被包装了两层,分别是HeartbeatHandler和AllChannelHandler.</p>
<p>HeartbeatHandler实现了识别心跳数据的功能.防止进入到业务里去,结合IdleSateHandler会刷新最新的数据读写时间.如果一直没有收到心跳/业务数据,channel将被关闭.</p>
<h3 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h3><p>TODO</p>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>flydzt</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/netty%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/">
        ← prev <!--netty 组件简介-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/%E8%AE%B0%E4%B8%80%E6%AC%A1dubbo%E5%8E%8B%E6%B5%8B/">
        <!--记一次dubbo压测--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2020 flydzt. </section>
        </footer>
    </body>
</html>


