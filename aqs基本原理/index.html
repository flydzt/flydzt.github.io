<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="解决一类问题而不是一个问题">
        <link rel="shortcut icon" href="/images/hhh.jpg"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="flydzt" href="">
        <title>aqs基本原理 | flydzt</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.0"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/images/hhh.jpg" alt="flydzt" /></a>
            <h1><a href="/">flydzt</a></h1>
            <p></p>
            <div id="follow-icons">
          <a href="http://github.com/flydzt" target="_blank" rel="noopener"><i class="fa fa-github-square fa-2x"></i></a>
          </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  四月 11, 2020
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/java/'>java</a> 
    
      <a href='/tags/concurrent/'>concurrent</a> 
    
    </span>
  

  <h1 class="post-title">aqs基本原理</h1>
  <section class="post-content article-entry">
    <h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>通过cas去获取主动权,失败就去排队.持有锁的解锁后唤醒下一个, 被唤醒后的线程看看自己是不是排到了第一.</p>
<p>值得注意的是,排队时候是可以取消的.从队列中删除某个节点,不能出现死循环,指向错误的问题.</p>
<p>由于支持节点的取消:</p>
<ul>
<li>next是不可靠的, 只能使用prev去遍历</li>
<li>遍历可能是不完全的,只靠release的时候去唤醒是不够的,取消的时候也要支持唤醒</li>
</ul>
<p>本文将描述三个部分: cas, 排队, 唤醒.</p>
<p>基本上就是解释下面这个代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire 是一个cas操作 不成功就入队</span></span><br><span class="line">    <span class="comment">//addWaiter 入队 需要注意多个线程同时入队的操作</span></span><br><span class="line">    <span class="comment">//acquireQueued 判断自己是不是第一,不是的话继续park</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//如果中途被发送了中断信号,那就中断自己</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h2><p>cas全称为compareAndSet. 比较和设值是一个原子操作, 例如cas(v, 1, 2), v是我要设值的变量, 1 为期望值, 2 为目标值. 只有v在等于1的时候能够被设置为2且返回true,其余时候都返回false.</p>
<p>请务必保证v被volatile修饰,各线程才能正常竞争.</p>
<h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>有了cas,获取锁的操作就很简单.写了一个无法排队和阻塞的锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录状态,每lock一次,就+1,反之-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录谁持有这个锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread current = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取,非阻塞</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current == Thread.currentThread()) &#123;</span><br><span class="line">            <span class="comment">//本线程已经持有该锁,重入+1</span></span><br><span class="line">            state.addAndGet(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//依靠cas最多只让一个线程到达这里</span></span><br><span class="line">            <span class="comment">//当然可以多判断一下state目前是不是等于0再cas</span></span><br><span class="line">            current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有持有该锁的线程进行unlock抛错</span></span><br><span class="line">        <span class="keyword">if</span> (current != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state.get() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//提前解绑 再把state置为0</span></span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在java里面,只能通知一个线程中断,不存在抢占式中断.所以不用担心这里不能设置为0</span></span><br><span class="line">        state.addAndGet(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但aqs的重点并不是cas,是排队,cas是一种同步的手段,只让一个线程操作成功.</p>
<p>在ReentrantLock的实现中,有公平锁和非公平锁两种实现,顾名思义,公平锁不允许插队.已经有人在排队了,则只能添加到队列末位. 而非公平锁则允许插队.</p>
<p>非公平锁存在饿死的情况,老是被插队,队列中的线程得不到执行的机会.但是和公平锁相比,在刚好锁可用的情况下,减少了一次线程的入队阻塞和一次线程的唤醒.性能会更好.</p>
<p>ReentrantLock中的state是一个计数, 只要state&gt;0,肯定有一个独占线程.state==0,独占线程为null.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公平</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没人排队,并且cas成功才能获取到锁</span></span><br><span class="line">        <span class="comment">//是否有人排队的判断就算不够及时也没有关系,本线程进入排队后会立刻查看自己是否在第一位,如果是的话,就会获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        <span class="comment">//很多线程可以同时执行到这里.大家都认为没人排队</span></span><br><span class="line">        <span class="comment">//需要cas同步,只让一个人通过,否则会有多个线程同时获取锁</span></span><br><span class="line">        <span class="comment">//这个cas的时候,可能有人在排队了,也可能没人在排队但有人获取了锁,不过state都会是大于0</span></span><br><span class="line">        <span class="comment">//也有可能在短时间内,有人获取了锁又释放了,产生了aba问题,这时候是能成功cas的,aba在这个场景没有副作用</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//设置独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//如果已经持有 重入</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">//达到了最大值,溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非公平</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//唯一的区别在于不需要判断是否有人在排队,其他是一样的</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h2><p>排队的第一步是生成一个Node入队.aqs维护head和tail,队列为一个双向链表.</p>
<p>每个node需要对应一个thread,也需要记录对应的状态.</p>
<p>状态有</p>
<ul>
<li>cancelled = 1 表示被取消 被取消的node需要被移除队列<ul>
<li>移出队列有几种方法,一种是被别人跳过,一种是取消时自我移除. 自我移除的同时,如果前面节点同时在取消,那么会失败</li>
</ul>
</li>
<li>signal = -1 表示需要唤醒下一个node,换句话说:后面的node在这里打个标记,告知别人这个node后面有需要唤醒的node</li>
<li>condition = -2 表示在wait condition</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//acquire的mode是独占</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//当前的tail</span></span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//prev指向旧tail,这时候tail可能是发生变化的</span></span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="comment">//将tail通过cas设置成当前node 只有tail不变的情况下,才能设置成功</span></span><br><span class="line">            <span class="comment">//如果失败,有两种情况</span></span><br><span class="line">            <span class="comment">//一种是别的线程要入队比本线程更早成功</span></span><br><span class="line">            <span class="comment">//一种是tail节点被取消,而被移除队列</span></span><br><span class="line">            <span class="comment">//当然也可以存在一个node成为新tail然后又取消出队的情况,aba没有副作用</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                <span class="comment">//成功后,oldTail就是前一个节点了,将next指向新的tail</span></span><br><span class="line">                <span class="comment">//如果这个时候oldTail被移除队列了,其实没有关系</span></span><br><span class="line">                <span class="comment">//因为前面可用的node指向了本node.而oldTail的引用将不会有人再持有,等待垃圾回收</span></span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//队列还不存在,初始化一下</span></span><br><span class="line">            <span class="comment">//初始化也是通过cas(null, new Node())设置head, tail=head</span></span><br><span class="line">            <span class="comment">//也可能设置失败,被别的线程先设置了</span></span><br><span class="line">            <span class="comment">//头结点只是一个空结点</span></span><br><span class="line">            <span class="comment">//无论如何,都需要进入下一个循环去排队</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图简单的表示两个线程想要排队的情形,是cas的直观表述,下图不包括队列为空,有人取消node等情形:</p>
<p><img src="/images/juc/addWaiter.jpg" alt="addWaiter"></p>
<p>入队后的node(thread),会在一个循环中,判断自己是不是排到了第一个,不是的话就挂起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数node就是入队时生成的node</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//node自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前一个node</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前一个node是head并且抢到了主动权</span></span><br><span class="line">            <span class="comment">//按道理我被唤醒只要前一个是head(head是一个空结点),就轮到我执行了</span></span><br><span class="line">            <span class="comment">//公平锁的情况下,我肯定能tryAcquire成功</span></span><br><span class="line">            <span class="comment">//但是非公平锁的情况下,就算我的前一个是head,tryAcquire不一定是会成功的</span></span><br><span class="line">            <span class="comment">//因为非公平锁,别的线程可以不考虑队列是否为空就去tryAcquire,本线程是和别的线程一起竞争</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果我获取成功了,那我已经获取了锁了</span></span><br><span class="line">                <span class="comment">//把本节点设置为head,并且将thread置空,成为空节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则判断一下是否需要park</span></span><br><span class="line">            <span class="comment">//虽然我的前面一个node不是head,但是可能前面的节点都是被取消的</span></span><br><span class="line">            <span class="comment">//我只要清理掉取消的node,我的前一个node就可能是head了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                <span class="comment">//native park 等待被唤醒</span></span><br><span class="line">                <span class="comment">//可能是中断唤醒的,而不是被正常唤醒的</span></span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//出现问题 取消</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要park</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//已经做过清理打过标记了,安心去park</span></span><br><span class="line">        <span class="comment">//但是假设我排在第二,我先判断第一节点是signal的,然后park了,接着持有锁的线程释放锁,第一个节点被unpark</span></span><br><span class="line">        <span class="comment">//恰好这时候第一节点又被取消了,unpark会拿到一个取消结点,那么按照顺序本节点应该要被唤醒</span></span><br><span class="line">        <span class="comment">//所以unpark需要遍历去找到第二个节点,next是不可靠的,只能靠prev去遍历</span></span><br><span class="line">        <span class="comment">//但prev遍历也会存在无法遍历全节点的问题</span></span><br><span class="line">        <span class="comment">//假如我是在prev遍历的时候加入的,遍历时队列只有第一个取消结点,接着加入了第二个可用结点,那么遍历会认为队列是空了</span></span><br><span class="line">        <span class="comment">//所以需要第一个节点取消的时候去唤醒第二个节点,所以取消操作的时候,如果前一个节点是头结点,需要唤醒下一个可用结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前一个node是取消的</span></span><br><span class="line">    <span class="comment">//就算做过清理了,清理后可能被置为取消.cas为signal没有成功</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前置节点是取消状态,那么清理掉前面连续的取消结点.</span></span><br><span class="line">        <span class="comment">//如果前面的node被取消,并且在做自我清理,不会影响到这里,当然自我清理可能失败</span></span><br><span class="line">        <span class="comment">//一个节点不能从取消回到非取消状态,那么只要是取消就可以跳过</span></span><br><span class="line">        <span class="comment">//自我清理失败的结果是:prev指向了前面,而前面对应的next没有指向取消结点的下一个结点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//这里是唯二能够真正清理掉取消结点的地方</span></span><br><span class="line">        <span class="comment">//还有一个是cancel的时候,把前一个可用结点的next做cas操作指向后面</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这时候,这个节点可能在取消,那么ws就会是cancel,就不能设置为signal</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//那就再来一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//置空 成为空node</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过被取消的node</span></span><br><span class="line">    <span class="comment">// 但是停下的地方可能一会儿也被取消</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pred取消了, predNext可能是pred</span></span><br><span class="line">    <span class="comment">//也可能一会儿发生改变</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//置为取消状态</span></span><br><span class="line">    <span class="comment">//可能有别的结点把这个结点设置成了signal,取消就是了</span></span><br><span class="line">    <span class="comment">//但这时候后面的节点先判断是signal然后去park了,结果这里又被设置为取消,那么后面的节点可能需要被唤醒</span></span><br><span class="line">    <span class="comment">//是否要唤醒,依赖于前方是否还有可用结点,如果有的话,那就不需要了,如果没有,那就是需要的</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是尾结点,将最后一个非取消结点置为尾结点</span></span><br><span class="line">    <span class="comment">//如果有新的线程入队,cas将会失败.但是入队操作会帮我们把node的next指向了新的tail,这样就把node留在了队列里.</span></span><br><span class="line">    <span class="comment">//不过新的入队线程会马上把我们给跳过清理掉</span></span><br><span class="line">    <span class="comment">//这里也可能aba,新线程入队,马上被取消出队,没有副作用</span></span><br><span class="line">    <span class="comment">//pred这时候可能是取消的</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">//把尾结点的next置为null</span></span><br><span class="line">        <span class="comment">//如果这时候又有新的入队,则next已经不是predNext,将会失败</span></span><br><span class="line">        <span class="comment">//或者pred取消了,指向了自己</span></span><br><span class="line">        <span class="comment">//或者pred取消前新线程入队,新线程还未将oldTail的next指向新node,pred取消后next指向自己,然后又被新线程指向了新的tail</span></span><br><span class="line">        pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">//如果前一个有效结点不是头结点 尝试把前一个有效结点置为signal</span></span><br><span class="line">        <span class="comment">//如果前一个节点这时候取消了,那么就会失败</span></span><br><span class="line">        <span class="comment">//能置成功或者本来就是signal的,说明前面这个结点没有被取消,否则就不清楚前方什么情况</span></span><br><span class="line">        <span class="comment">//那么需要调用unpark,指不定前方没有节点可用了</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">            (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL)))</span><br><span class="line">            &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进到这里只是为了确定,前一个节点此时没有被取消</span></span><br><span class="line">            <span class="comment">//如果进来后前一个结点要取消或者取消到一半,不会影响到后面的操作</span></span><br><span class="line">            <span class="comment">//每一个取消操作,都可能调用unpark,所以我只保证前面有节点可用,我就不会去unpark</span></span><br><span class="line">            <span class="comment">//如果没有进来,说明我不知道前面是否有节点可用,保守起见,我调用unpark</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">//尝试摘掉自己和前面所有的取消结点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//pred的next可能指向了自己,也可能指向了更后面的节点</span></span><br><span class="line">                <span class="comment">//1 pred取消后指向了自己</span></span><br><span class="line">                <span class="comment">//2 有更后面的取消结点比我更先操作pred,那么pred会指向更后面,比如pred成了尾结点</span></span><br><span class="line">                pred.compareAndSetNext(predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//前一个节点可能是head,那么需要唤醒下一个node</span></span><br><span class="line">            <span class="comment">//这里的这个操作是必要的</span></span><br><span class="line">            <span class="comment">//只靠release来唤醒是不够的 如果刚好有新线程在入队,那么release操作就无法遍历到新线程去唤醒</span></span><br><span class="line">            <span class="comment">//另一方面,不清楚前方状况,全局看一下</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这时候后面的节点都被取消了,这个结点成了尾结点,这个next可能在新线程入队的时候又被指向了新的tail</span></span><br><span class="line">        <span class="comment">//也可能在shouldPark往前跳过取消结点时,赋值给下一个结点</span></span><br><span class="line">        <span class="comment">//如果这里不做这个操作,同时acquireQueued函数里,head.next不被置为null,next遍历也会是可靠的??</span></span><br><span class="line">        <span class="comment">//只要next不会指向前面的结点形成循环,不会被置为null</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h2><p>release后,将自己置为signal,唤醒下一个node.如果没有人在排队,直接返回.</p>
<h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//和tryAcquire相反的操作 就不会区分公平非公平了,因为只有一个线程获取了锁</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//先置空线程</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有之前acquire成功的才能tryRelease成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//如果acquire是在队列空的时候,不用排队,也就没有head</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果有队列的话,唤醒head下一个node</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这时候有人排队了,要靠它自己入队时的自旋来获取锁</span></span><br><span class="line">    <span class="comment">//就不是触发式的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里node.next可能会是node自身</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//下一个结点是个空或者在取消</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从后往前遍历找到最前面的</span></span><br><span class="line">        <span class="comment">//如果是从前往后去找,找到某个节点后,这个结点被取消,然后next指向了自己,就悲剧了.</span></span><br><span class="line">        <span class="comment">//如果有新线程入队,这个新线程不能被遍历到,这点会带来一个隐患,是node自旋无法解决的:</span></span><br><span class="line">        <span class="comment">//考虑p赋值为tail后, 新线程入队,然后新线程查看自己是不是第一位</span></span><br><span class="line">        <span class="comment">//不是第一位,然后尝试往前跳过取消结点,发现依然不是第一位</span></span><br><span class="line">        <span class="comment">//这时候新线程被挂起,接着前面的节点都取消了</span></span><br><span class="line">        <span class="comment">//这时候除了取消操作里去唤起,没有别的操作能唤起这个线程了</span></span><br><span class="line">        <span class="comment">//所以cancel的函数里是需要调用本函数的</span></span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能队列空了,可能是新线程没有被遍历到</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>flydzt</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/jvm%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
        ← prev <!--jvm线程模型的一些基础知识-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C/">
        <!--记一次mysql自增主键用完--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2020 flydzt. </section>
        </footer>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>


