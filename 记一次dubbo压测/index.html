<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="解决一类问题而不是一个问题">
        <link rel="shortcut icon" href="/images/hhh.jpg"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="flydzt" href="">
        <title>记一次dubbo压测 | flydzt</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.0"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/images/hhh.jpg" alt="flydzt" /></a>
            <h1><a href="/">flydzt</a></h1>
            <p></p>
            <div id="follow-icons">
          <a href="http://github.com/flydzt" target="_blank" rel="noopener"><i class="fa fa-github-square fa-2x"></i></a>
          </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  十二月 25, 2019
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/java/'>java</a> 
    
      <a href='/tags/dubbo/'>dubbo</a> 
    
    </span>
  

  <h1 class="post-title">记一次dubbo压测</h1>
  <section class="post-content article-entry">
    <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>上线了一个熔断降级功能，想做一个压测看下qps.</p>
<p>熔断降级非常简单,耗时偏高时返回缓存而不是实时计算.在大压力情况下,只会返回缓存</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>一台服务器部署服务,另一台服务器部署客户端进行压测.</p>
<p>服务器均为40核,内存足够不会swap.</p>
<p>服务端使用java11, dubbo2.5.3版本, 内存为6g, g1收集器.其他dubbo参数如下:</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>protocol.name</td>
<td>dubbo</td>
<td>默认协议默认序列化</td>
</tr>
<tr>
<td>protocol.connections</td>
<td>3</td>
<td>client数</td>
</tr>
<tr>
<td>protocol.accepts</td>
<td>1000</td>
<td>服务端能接受的client</td>
</tr>
<tr>
<td>protocol.threads</td>
<td>512</td>
<td>服务端处理线程池</td>
</tr>
<tr>
<td>service.executes</td>
<td>512</td>
<td>服务端最大并行请求数</td>
</tr>
</tbody></table>
<p>客户端使用相同版本的dubbo, 以及<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">jmh</a>,逻辑非常简单,调用服务,如果成功记一次succ(retCode=0),如果出错记一次error,如果失败记一次fail(retCode!=0).</p>
<p>单次请求返回数据大小在300k左右.</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在压测过程中,客户端唯一会产生的error为timeout.没有产生fail,说明不会有其他错误问题,服务端的缓存都是正常的(否则retCode!=0).</p>
<p>客户端32线程时,几乎没有error. qps大概在1000左右.</p>
<p>客户端64线程时,几乎全是error. qps大概在1000左右.并且此时服务端gc几乎无法回收空间.</p>
<p>按道理,要么cpu被压满,要么io被压满.但是在64线程下,这两者都没有达到瓶颈就不能再提升qps了.</p>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>怀疑在64线程时,服务端来不及处理这么多的请求</p>
<p>于是在32线程和64线程的情况下查看服务端的heap_dump和thread</p>
<blockquote>
<p>这里使用的是<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html" target="_blank" rel="noopener">jcmd</a>命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jcmd &lt;pid&gt; GC.heap_dump ~/mydump.hprof</span><br><span class="line">jcmd &lt;pid&gt; Thread.print &gt; ~/mythread.txt</span><br></pre></td></tr></table></figure>

<p>由于堆栈都具有瞬时性,在压测时隔一会儿dump一个,至少三个.</p>
<p>查看堆栈信息发现,64线程时堆中有大量的NioAcceptedSocketChannel$WriteRequestQueue对象,占用将近4g,查看内部的内容发现就是需要返回的对象.</p>
<p>线程中绝大部分的DubboServerHandler线程处在等待状态.</p>
<p>综上两点,说明不是服务端处理不过来请求.而是数据发不出去</p>
<blockquote>
<p>查看堆和线程栈工具为mat和jca457</p>
<p>需要注意mat 32位和64位需要和本机java匹配</p>
</blockquote>
<p>怀疑是网卡被打满了,查看传输速率.数据传输量在300m/s.查看网卡为万兆网卡.说明网卡绰绰有余.</p>
<blockquote>
<p>查看网络传输量命令为dstat,该命令不仅可以看net,也可以看cpu,disk等指标.</p>
<p>查看网卡带宽的命令为ethtool.</p>
</blockquote>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>对客户端使用相同的方法获取堆栈信息.</p>
<p>发现io线程大量阻塞在dubbo的SerializerFactory.getSerializer方法上.显示lock在一个HashMap</p>
<p>查看代码发现dubbo为需要序列化的类缓存了对应的Serializer,由于使用的是HashMap,取出时需要加锁.在高并发情况下,产生了严重的竞争.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_cachedSerializerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//这里会产生竞争</span></span><br><span class="line">     <span class="comment">//如果不加锁,put存入缓存的时候get可能导致HashMap100%占用cpu的问题.是因为rehash会倒着处理链表,导致此时get可能进入一个闭合的链表.</span></span><br><span class="line">     <span class="comment">//在java1.8之后HashMap按照正的顺序rehash,所以以后不会出现这个问题.但是此时的get行为肯定是有问题的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (_cachedSerializerMap) &#123;</span><br><span class="line">        serializer = (Serializer) _cachedSerializerMap.get(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改序列化方式为java再进行压测.64线程下qps升到了4700,极少数的error,数据量也涨到了900m/s.此时客户端和服务端的cpu都在2000%左右.</p>
<blockquote>
<p>java的序列化方式使用ObjectInputStream和ObjectOutputStream.</p>
<p>这里java序列化只是为了测试,java序列化无法跨语言,cpu占用高,且码流很大.并不适用于生产环境.</p>
</blockquote>
<p>继续提升压测线程数,客户端将耗尽cpu资源,产生大量超时,qps更低.</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="升级版本"><a href="#升级版本" class="headerlink" title="升级版本"></a>升级版本</h3><p>修改序列化方式治标不治本,dubbo2.5.3提供的序列化也十分有限.</p>
<p>查看了2.7.3中的实现.该缓存已经改为ConcurrentHashMap.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (_cachedSerializerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//这里就不需要加锁了 靠ConcurrentHashMap的segment加锁来避免大量竞争</span></span><br><span class="line">     <span class="comment">//并且get是不加锁的 哪怕对同一个key不停的get 也不会产生竞争</span></span><br><span class="line">    serializer = (Serializer) _cachedSerializerMap.get(cl);</span><br><span class="line">    <span class="keyword">if</span> (serializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO 业务暂无升级dubbo的打算,但是客户端可以使用dubbo 2.7.3进行测试.</p>
</blockquote>
<p>对于业务来说,升级dubbo版本应该是最好的选择.</p>
<h3 id="其他待优化点"><a href="#其他待优化点" class="headerlink" title="其他待优化点"></a>其他待优化点</h3><p>服务端dubbo的handler线程大多数都是空闲状态,可以dump正常服务时的线程栈看看是否真的需要512个处理线程.单个线程256k,能节省不少内存资源.</p>
<p>数据量大的情况下,可以增大protocol里的connections.增大connections不要忘记增大accepts.</p>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>flydzt</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/dubbo%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1/">
        ← prev <!--dubbo的远程通信-->
    </a>
    
    <span class="page-number">•</span>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2020 flydzt. </section>
        </footer>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>


